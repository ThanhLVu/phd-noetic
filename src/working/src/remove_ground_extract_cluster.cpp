/* \author Bastian Steder */

#include "ros/ros.h"
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>

#include <Eigen/Dense>

#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/range_image/range_image.h>
#include <pcl/visualization/range_image_visualizer.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/features/range_image_border_extractor.h>
#include <pcl/console/parse.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/point_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/sample_consensus/ransac.h>
#include <pcl/sample_consensus/sac_model_plane.h>
#include <pcl/search/search.h>
#include <pcl/kdtree/kdtree.h>
#include <pcl/search/kdtree.h>
#include <pcl/features/normal_3d.h>
#include <pcl/segmentation/extract_clusters.h>

//#include "expand_search.h"

typedef pcl::PointXYZ PointType;

pcl::PCLPointCloud2 *cloud = new pcl::PCLPointCloud2;
pcl::PCLPointCloud2ConstPtr cloudPtr(cloud);
pcl::PCLPointCloud2 cloud_downsampled;
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_removed_ground(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_removed_background(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_clustered(new pcl::PointCloud<pcl::PointXYZRGB>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_background(new pcl::PointCloud<pcl::PointXYZ>);

float voxel_grid_size = 0.005f;

// --------------
// -----Callback function-----
// --------------
void convertRosMSGPointCloud(const sensor_msgs::PointCloud2ConstPtr &msg) {
    // Convert to PCL data type
    pcl_conversions::toPCL(*msg, *cloud);

    // Downsampling input point cloud
    pcl::VoxelGrid<pcl::PCLPointCloud2> sor;
    sor.setInputCloud(cloudPtr);
    sor.setLeafSize(voxel_grid_size, voxel_grid_size, voxel_grid_size);
    sor.filter(cloud_downsampled);

    pcl::fromPCLPointCloud2(cloud_downsampled, *cloud_filtered);

    /**************************Filter by range*************************/
    pcl::PassThrough<pcl::PointXYZ> pass;
    pass.setInputCloud(cloud_filtered);
    pass.setFilterFieldName("z");
    pass.setFilterLimits(0.0, 5.0);
    pass.filter(*cloud_filtered);

    boost::shared_ptr <pcl::visualization::PCLVisualizer> viewer_test;
    viewer_test.reset(new pcl::visualization::PCLVisualizer("Debugging screen"));
    viewer_test->setBackgroundColor(0, 0, 0);
    viewer_test->addPointCloud(cloud_filtered, "all");
    viewer_test->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "all");
//    viewer_test->addCoordinateSystem(1.0, "World");
    viewer_test->initCameraParameters();

    while (!viewer_test->wasStopped()) {
        viewer_test->spinOnce(100);
        ros::Duration(0.1).sleep();
    }
}

// --------------
// -----Find projection of Origin (0,0,0) on RANSAC generated surface-----
// --------------
std::vector<float> projectOrigin(pcl::ModelCoefficients coefficients) // Assumption: coefficients(a,b,c,d)
{
    float a = coefficients.values.at(0);
    float b = coefficients.values.at(1);
    float c = coefficients.values.at(2);
    float d = coefficients.values.at(3);

    float t = -d / (pow(a,2.0) + pow(b, 2.0) + pow(c, 2.0));

    std::vector<float> projection;
    projection.resize(3);
    projection.at(0) = a * t;
    projection.at(1) = b * t;
    projection.at(2) = c * t;

    return projection;
}

// --------------
// -----Locate points behind surface generated by RANSAC-----
// --------------
pcl::PointIndices getPointBehindIndices(std::vector<float> origin_projection) // Assumption: origin_projection(x,y,z)
{
    Eigen::Vector3f toOriginVec, toPointVec;
    pcl::PointIndices point_behind_indices;

    point_behind_indices.indices.clear();

    toOriginVec(0) = -origin_projection.at(0);
    toOriginVec(1) = -origin_projection.at(1);
    toOriginVec(2) = -origin_projection.at(2);

    for(int i=0; i<cloud_removed_ground->points.size(); i++)
    {
        toPointVec(0) = cloud_removed_ground->points.at(i).x - origin_projection.at(0);
        toPointVec(1) = cloud_removed_ground->points.at(i).y - origin_projection.at(1);
        toPointVec(2) = cloud_removed_ground->points.at(i).z - origin_projection.at(2);

        if(toOriginVec.dot(toPointVec) < 0)
            point_behind_indices.indices.push_back(i);
    }

    std::cout << "Got " << point_behind_indices.indices.size() << " points behind RANSAC generated plane and "
              << cloud_removed_ground->points.size() - point_behind_indices.indices.size() << " points infront" << std::endl;

    return point_behind_indices;
}

// --------------
// -----Generate clusters group (color, what the cloud looks like)-----
// --------------
uint32_t randomizeColorCode()
{
//    int r = generateRandomNumber() % 255;
//    int g = generateRandomNumber() % 255;
//    int b = generateRandomNumber() % 255;
    int r = rand();
    int g = rand();
    int b = rand();
    uint32_t current_cluster_color = ((uint32_t)r << 16 | (uint32_t)g << 8 | (uint32_t)b);
    return current_cluster_color;
}

void generateClusteredCloud(std::vector<pcl::PointIndices> cluster_indices)
{
    cloud_clustered->clear();
    pcl::PointXYZRGB current_point;
    uint32_t current_cluster_color = 0;

    for(int cluster_index=0; cluster_index<cluster_indices.size(); cluster_index++)
        {
        current_cluster_color = randomizeColorCode();
        for(int point_index=0; point_index<cluster_indices.at(cluster_index).indices.size(); point_index++)
            {
            current_point.x = cloud_removed_background->at(cluster_indices.at(cluster_index).indices.at(point_index)).x;
            current_point.y = cloud_removed_background->at(cluster_indices.at(cluster_index).indices.at(point_index)).y;
            current_point.z = cloud_removed_background->at(cluster_indices.at(cluster_index).indices.at(point_index)).z;
            current_point.rgb = *reinterpret_cast<float*>(&current_cluster_color);

            cloud_clustered->push_back(current_point);
            }
        }

    std::cout << "Cloud after background removed: " << cloud_removed_background->points.size() << std::endl;
    std::cout << "Cloud after clustered: " << cloud_clustered->points.size() << std::endl;

    boost::shared_ptr <pcl::visualization::PCLVisualizer> viewer_test;
    viewer_test.reset(new pcl::visualization::PCLVisualizer("Debugging screen"));
    viewer_test->setBackgroundColor(0, 0, 0);
    viewer_test->addPointCloud(cloud_clustered, "all");
    viewer_test->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "all");
//    viewer_test->addCoordinateSystem(1.0, "World");
    viewer_test->initCameraParameters();

    while (!viewer_test->wasStopped()) {
        viewer_test->spinOnce(100);
        ros::Duration(0.1).sleep();
    }
}


// --------------
// -----Ground Plane Removal Function-----
// --------------
void removeGround()
{
    pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients ());
    pcl::PointIndices::Ptr inliers (new pcl::PointIndices ());
    // Create the segmentation object
    pcl::SACSegmentation<pcl::PointXYZ> seg;
    // Optional
    seg.setOptimizeCoefficients (true);
    // Mandatory
    seg.setModelType (pcl::SACMODEL_PLANE);
    seg.setMethodType (pcl::SAC_RANSAC);
    seg.setMaxIterations (1000);
    seg.setDistanceThreshold (0.01);

    // Create the filtering object
    pcl::ExtractIndices<pcl::PointXYZ> extract;

    // Segment the largest planar component from the remaining cloud
    seg.setInputCloud (cloud_filtered);
    seg.segment (*inliers, *coefficients);

    // Extract the inliers
    extract.setInputCloud (cloud_filtered);
    extract.setIndices (inliers);
    extract.setNegative (true);
    extract.filter (*cloud_removed_ground);

    // Remove points behind RANSAC surface
    pcl::PointIndices::Ptr point_behind_indices (new pcl::PointIndices ());
    *point_behind_indices = getPointBehindIndices(projectOrigin(*coefficients));

    pcl::ExtractIndices<pcl::PointXYZ>::Ptr indices_extract_(new pcl::ExtractIndices<pcl::PointXYZ>);
    indices_extract_->setInputCloud(cloud_removed_ground);
    indices_extract_->setIndices(point_behind_indices);
    indices_extract_->filter(*cloud_background);
    indices_extract_->setNegative(true);
//    indices_extract_->setKeepOrganized (true);
    indices_extract_->filter(*cloud_removed_background);

    boost::shared_ptr <pcl::visualization::PCLVisualizer> viewer_test;
    viewer_test.reset(new pcl::visualization::PCLVisualizer("Debugging screen"));
    viewer_test->setBackgroundColor(0, 0, 0);
    viewer_test->addPointCloud(cloud_removed_background, "all");
    viewer_test->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "all");
//    viewer_test->addCoordinateSystem(1.0, "World");
    viewer_test->initCameraParameters();

    while (!viewer_test->wasStopped()) {
        viewer_test->spinOnce(100);
        ros::Duration(0.1).sleep();
    }

    // Creating the KdTree object for the search method of the extraction
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud (cloud_filtered);

    std::vector<pcl::PointIndices> cluster_indices;
    cluster_indices.clear();

    pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
    ec.setClusterTolerance (0.03); // 1cm
    ec.setMinClusterSize (200);
    ec.setMaxClusterSize (50000);
    ec.setSearchMethod (tree);
    ec.setInputCloud (cloud_removed_background);
    ec.extract (cluster_indices);

    std::cout << "I clustered " << cluster_indices.size() << " set" << std::endl;

    generateClusteredCloud(cluster_indices);

    viewer_test.reset(new pcl::visualization::PCLVisualizer("Debugging screen"));
    viewer_test->setBackgroundColor(0, 0, 0);
    viewer_test->addPointCloud(cloud_removed_background, "all");
    viewer_test->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "all");
//    viewer_test->addCoordinateSystem(1.0, "World");
    viewer_test->initCameraParameters();

    while (!viewer_test->wasStopped()) {
        viewer_test->spinOnce(100);
        ros::Duration(0.1).sleep();
    }
}


// --------------
// -----Extract Borders Function-----
// --------------
/*int
extractBorders ()
{
  // ------------------------------------------------------------------
  // -----Read PointCloud and RangeImage objects-----
  // ------------------------------------------------------------------
  pcl::PointCloud<PointType>& point_cloud = *cloud_removed_ground;

  // -----------------------------------------------
  // -----Create RangeImage Parameters-----
  // -----------------------------------------------
  float angular_resolution = (float) (  1.0f * (M_PI/180.0f));  //   1.0 degree in radians
  float max_angle_width     = (float) (360.0f * (M_PI/180.0f));  // 360.0 degree in radians
  float max_angle_height    = (float) (180.0f * (M_PI/180.0f));  // 180.0 degree in radians
  Eigen::Affine3f scene_sensor_pose = (Eigen::Affine3f)Eigen::Translation3f(0.0f, 0.0f, 0.0f);
  pcl::RangeImage::CoordinateFrame coordinate_frame = pcl::RangeImage::CAMERA_FRAME;
  float noise_level = 0.0;
  float min_range = 0.0f;
  int border_size = 1;
  
  // -----------------------------------------------
  // -----Create RangeImage from the PointCloud-----
  // -----------------------------------------------
  pcl::RangeImage::Ptr range_image_ptr (new pcl::RangeImage);
  pcl::RangeImage& range_image = *range_image_ptr;   
  range_image.createFromPointCloud (point_cloud, angular_resolution, max_angle_width, max_angle_height,
                                   scene_sensor_pose, coordinate_frame, noise_level, min_range, border_size);
  range_image.setUnseenToMaxRange ();

  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  pcl::visualization::PCLVisualizer viewer ("3D Viewer");
  viewer.setBackgroundColor (1, 1, 1);
//  viewer.addCoordinateSystem (1.0f, "global");
  pcl::visualization::PointCloudColorHandlerCustom<PointType> point_cloud_color_handler (cloud_filtered, 0, 0, 0);
  viewer.addPointCloud (cloud_filtered, point_cloud_color_handler, "original point cloud");
  //PointCloudColorHandlerCustom<pcl::PointWithRange> range_image_color_handler (range_image_ptr, 150, 150, 150);
  //viewer.addPointCloud (range_image_ptr, range_image_color_handler, "range image");
  //viewer.setPointCloudRenderingProperties (PCL_VISUALIZER_POINT_SIZE, 2, "range image");
  
  // -------------------------
  // -----Extract borders-----
  // -------------------------
  pcl::RangeImageBorderExtractor border_extractor (&range_image);
  pcl::PointCloud<pcl::BorderDescription> border_descriptions;
  border_extractor.compute (border_descriptions);
  
  // ----------------------------------
  // -----Show points in 3D viewer-----
  // ----------------------------------
  pcl::PointCloud<pcl::PointWithRange>::Ptr border_points_ptr(new pcl::PointCloud<pcl::PointWithRange>),
                                            veil_points_ptr(new pcl::PointCloud<pcl::PointWithRange>),
                                            shadow_points_ptr(new pcl::PointCloud<pcl::PointWithRange>);
  pcl::PointCloud<pcl::PointWithRange>& border_points = *border_points_ptr,
                                      & veil_points = * veil_points_ptr,
                                      & shadow_points = *shadow_points_ptr;
  for (int y=0; y< (int)range_image.height; ++y)
  {
    for (int x=0; x< (int)range_image.width; ++x)
    {
      if (border_descriptions[y*range_image.width + x].traits[pcl::BORDER_TRAIT__OBSTACLE_BORDER])
        border_points.points.push_back (range_image[y*range_image.width + x]);
      if (border_descriptions[y*range_image.width + x].traits[pcl::BORDER_TRAIT__VEIL_POINT])
        veil_points.points.push_back (range_image[y*range_image.width + x]);
      if (border_descriptions[y*range_image.width + x].traits[pcl::BORDER_TRAIT__SHADOW_BORDER])
        shadow_points.points.push_back (range_image[y*range_image.width + x]);
    }
  }
  pcl::visualization::PointCloudColorHandlerCustom<pcl::PointWithRange> border_points_color_handler (border_points_ptr, 0, 255, 0);
  viewer.addPointCloud<pcl::PointWithRange> (border_points_ptr, border_points_color_handler, "border points");
  viewer.setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 7, "border points");
//  pcl::visualization::PointCloudColorHandlerCustom<pcl::PointWithRange> veil_points_color_handler (veil_points_ptr, 255, 0, 0);
//  viewer.addPointCloud<pcl::PointWithRange> (veil_points_ptr, veil_points_color_handler, "veil points");
//  viewer.setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 7, "veil points");
//  pcl::visualization::PointCloudColorHandlerCustom<pcl::PointWithRange> shadow_points_color_handler (shadow_points_ptr, 0, 255, 255);
//  viewer.addPointCloud<pcl::PointWithRange> (shadow_points_ptr, shadow_points_color_handler, "shadow points");
//  viewer.setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 7, "shadow points");
  
  //-------------------------------------
  // -----Show points on range image-----
  // ------------------------------------
  pcl::visualization::RangeImageVisualizer* range_image_borders_widget = NULL;
  range_image_borders_widget =
  pcl::visualization::RangeImageVisualizer::getRangeImageBordersWidget (range_image, -std::numeric_limits<float>::infinity (), std::numeric_limits<float>::infinity (), false,
                                                                          border_descriptions, "Range image with borders");
  // -------------------------------------
  
  
  //--------------------
  // -----Main loop-----
  //--------------------
  while (!viewer.wasStopped ())
  {
    range_image_borders_widget->spinOnce ();
    viewer.spinOnce ();
    pcl_sleep(0.01);
  }
}*/

// --------------
// -----Main-----
// --------------
int main(int argc, char **argv)
{
  ros::init(argc, argv, "extract_borders");
  ros::NodeHandle nh;

//  ros::Subscriber pointcloud_sub = nh.subscribe("/sensor_d435/depth/points", 1, convertRosMSGPointCloud);
  ros::Subscriber pointcloud_sub = nh.subscribe("/camera/depth/color/points", 1, convertRosMSGPointCloud);

  ros::Rate loop_rate(10);

  srand (time(NULL));

  while (ros::ok())
  {
    /**
     * This is a message object. You stuff it with data, and then publish it.
     */
    if(cloud_filtered->size() > 10)
    {
        removeGround();
//        ExpandSearch expand_search(*cloud_removed_ground, voxel_grid_size);
//        extractBorders();
    }

    ros::spinOnce();
    loop_rate.sleep();
  }


  return 0;
}


